# vsCTF 2022 - Strongest RSA Challenge Writeup

## Description

I think getStrongPrime is not safe enough, so I implemented an RSA algorithm using the strongest primes ever. I don't think it's breakable unless you have a quantum computer!

## Challenge Source Code & Information

```python
from Crypto.Util.number import getStrongPrime, bytes_to_long
from sympy import prevprime, factorial
from math import gcd
import random

from secret import FLAG

e = 0x10001

def getStrongestPrime(nbits):
    while True:
        p = getStrongPrime(nbits)
        delta = random.randint(0x1337, 0x1337 + 0x1337)
        pp = p - delta
        ppp = prevprime(factorial(pp) % p)
        if gcd(ppp-1, e) == 1:
            return p, ppp
    
NBITS = 1024
p0, p = getStrongestPrime(NBITS)
q0, q = getStrongestPrime(NBITS)
N = p * q
m = bytes_to_long(FLAG.encode())
c = pow(m, e, N)

print(f"p0 = {p0}\nq0 = {q0}")
print(f"N = {N}\ne = {e}\nc = {c}")
```

```
p0 = 163753477176210014003355280732229891908166074468271556144642666169325605017666799921295576722168608401188682320182653287668989748162506955989407213845500704903463544753049275828138559289189335596749709834289278256382427251831790026921563375111737350084174473833546767952081017613072491759534988253353621530923
q0 = 157598184809589313845990455272198459548591786211953253450211152128535343234857067521711590445365424087430728267491317690639227988484930088637483194045435135802590588269993794073236513557034321374876808546159597997280236993358749182432517011554239468502233558179815446959403076134284375214662245037202945590183
N = 11884142558095727641000594156833818117849240126500615037738361957005811068956622520280143210434649198031005585252791693777710458190732464123269660559382653636999601459113099276826723072914352276709761755328542359490331355061792823458149611674845846523699218971126655186522340818792078719216860046464292413878045842425132308544311887062610272360069819975798905665533964761527225558339025724872067751916657135473510775709503714808686565298632040214249698116863336246844759838665285888816202570667521796553678688293761589082062045634768520102235077364345013564344229095323239077977717497503322831684471959195555281580807
e = 65537
c = 11776079752956619284016871274992903352398310565005810097721997339193718454945819135683541554652454321040530044545154341786048659896370226535387839157317585368391189570502841702311449000698372030666509296004039398083488490698999338894328619127149024309470011330855840757405205104944658961386764569043610715311746676861275270073394069269043429092551681704290340091149637137627751767730812255069347108706434972786681985484368054390699974613090342753508097177008167140924577095976699437810398922852319420301082587264411993737330188227703869101718515748828944300463051133118636928879090217708121368293440440444106196607645
```

## Solution

As we can see from the source code and information provided, we are given everything we need to decrypt the ciphertext except p and q which get calculated by the `getStrongestPrime()` function. The problem that we run into is the fact that we have to calculate the factorial of a very large number inorder to find out what p is. Luckily, we can use wilson's theorem to calculate `factorial(p-delta) % p` very fast. Wilson's theorem states that `(p-1)! = -1 (mod p)`, so that means `(p-1)*(p-2)*...*(p-delta+1)*(p-delta)! = -1 (mod p)`. But since we want to calculate `(p-delta)!` we will have to mutiply both sides by `inverse(t) where t is (p-1)*(p-2)*...*(p-delta+1)` which results in 
`(p-delta)! = -inverse(t) (mod p)`. We can make the RHS of the equation positive by `adding inverse(t) to p` => `p-(-invese(t))` => 
`(p-delta)! = (p-(-inverse(t))) (mod p)`. So we get the solution to `factorial(p-delta) % p` and from there on, getting the flag is pretty trivial. We can get the flag by bruteforcing the delta and getting the p and q values that we were missing.

Solver Script:
```python
from Crypto.Util.number import getStrongPrime, bytes_to_long
from sympy import prevprime, factorial
from math import gcd
import random

e = 65537
c = 11776079752956619284016871274992903352398310565005810097721997339193718454945819135683541554652454321040530044545154341786048659896370226535387839157317585368391189570502841702311449000698372030666509296004039398083488490698999338894328619127149024309470011330855840757405205104944658961386764569043610715311746676861275270073394069269043429092551681704290340091149637137627751767730812255069347108706434972786681985484368054390699974613090342753508097177008167140924577095976699437810398922852319420301082587264411993737330188227703869101718515748828944300463051133118636928879090217708121368293440440444106196607645
n = 11884142558095727641000594156833818117849240126500615037738361957005811068956622520280143210434649198031005585252791693777710458190732464123269660559382653636999601459113099276826723072914352276709761755328542359490331355061792823458149611674845846523699218971126655186522340818792078719216860046464292413878045842425132308544311887062610272360069819975798905665533964761527225558339025724872067751916657135473510775709503714808686565298632040214249698116863336246844759838665285888816202570667521796553678688293761589082062045634768520102235077364345013564344229095323239077977717497503322831684471959195555281580807

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m
       
def printFlag(inp):
    e=65537
    p = inp
    q = n//p
    phi = (p-1)*(q-1)
    d = pow(e,-1,phi)
    flag = hex(pow(c,d,n))[2:]
    try:
        ax = ''.join([chr(int(flag[i:i+2],16)) for i in range(0,len(flag),2)])
        if 'vs' in ax:
            print(ax)
            print()
    except:
        pass
      
def getStrongestPrime(nbits):
    p = 157598184809589313845990455272198459548591786211953253450211152128535343234857067521711590445365424087430728267491317690639227988484930088637483194045435135802590588269993794073236513557034321374876808546159597997280236993358749182432517011554239468502233558179815446959403076134284375214662245037202945590183
    for delta in range(4919,4919*2 + 1):
        pp = p - delta
        t=1
        for i in range(delta):
            t = (t * (p-delta+i)) % p 
        mod = p-modinv(t,p)
        ppp = prevprime(mod)
        if gcd(ppp-1, e) == 1:
            printFlag(ppp)
getStrongestPrime(1024)
```
